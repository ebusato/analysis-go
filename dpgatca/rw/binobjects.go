package rw

import (
	"encoding/binary"
	"fmt"
	"log"

	"gitlab.in2p3.fr/avirm/analysis-go/dpga/dpgadetector"
)

const (
	numAMCFrameCounters uint8  = 2
	numASMFrameCounters uint8  = 4
	numCounters         uint8  = 4
	numTimeStamps       uint8  = 4
	ctrlFirstWord       uint16 = 0x1230
	ctrl0xfe            uint16 = 0xfe
	ctrl0xfd            uint16 = 0xfd
	ctrl0xCafe          uint16 = 0xCAFE
	ctrl0xDeca          uint16 = 0xDECA
	ctrl0xCRC           uint16 = 0x9876
	ctrl0xfb            uint16 = 0xfb
)

type ChanData struct {
	// Raw quantities
	ParityChanIdCtrl uint16
	Amplitudes       []uint16

	// Derived quantities
	Channel uint16
}

type HalfDRSData struct {
	Data [4]ChanData
}

func (h *HalfDRSData) SetNoSamples(n uint16) {
	for i := range h.Data {
		h.Data[i].Amplitudes = make([]uint16, n)
	}
}

type ErrorCode int

const (
	ErrorCode1 ErrorCode = iota + 1 // value of error code if block has 4 extra 16 bits words after each sample block
)

// Frame is a single data frame produced by AMC
// Each frame is associated to one half DRS
type Frame struct {
	// Raw quantities
	FirstBlockWord   uint16
	AMCFrameCounters [numAMCFrameCounters]uint16
	ParityFEIdCtrl   uint16
	TriggerMode      uint16
	Trigger          uint16
	ASMFrameCounters [numASMFrameCounters]uint16
	Cafe             uint16
	Deca             uint16
	Counters         [numCounters]uint16
	TimeStamps       [numTimeStamps]uint16
	NoSamples        uint16
	Data             HalfDRSData
	CRC              uint16
	ParityFEIdCtrl2  uint16

	// Derived quantities
	AMCFrameCounter uint32
	FrontEndId      uint16
	ASMFrameCounter uint64
	TimeStamp       uint64
	QuartetAbsIdx60 uint8

	// Error handling
	Err ErrorCode

	// UDP Payload size in octects
	UDPPayloadSize int

	// for internal use
	noAttempts         int
	QuartetAbsIdx60old uint8
}

func NewFrame(udppayloadsize int, buffer []byte) *Frame {
	f := &Frame{}
	f.UDPPayloadSize = udppayloadsize
	f.FillHeader(buffer)
	err := f.IntegrityHeader()
	if err != nil {
		fmt.Println("IntegrityHeader check failed")
		f.Print("short")
		return nil
	}
	return f
}

func (f *Frame) FillHeader(buffer []byte) {
	buffer = buffer[:42]
	f.FirstBlockWord = binary.BigEndian.Uint16(buffer[0:2])
	f.AMCFrameCounters[0] = binary.BigEndian.Uint16(buffer[2:4])
	f.AMCFrameCounters[1] = binary.BigEndian.Uint16(buffer[4:6])
	f.ParityFEIdCtrl = binary.BigEndian.Uint16(buffer[6:8])
	f.TriggerMode = binary.BigEndian.Uint16(buffer[8:10])
	f.Trigger = binary.BigEndian.Uint16(buffer[10:12])
	f.ASMFrameCounters[0] = binary.BigEndian.Uint16(buffer[12:14])
	f.ASMFrameCounters[1] = binary.BigEndian.Uint16(buffer[14:16])
	f.ASMFrameCounters[2] = binary.BigEndian.Uint16(buffer[16:18])
	f.ASMFrameCounters[3] = binary.BigEndian.Uint16(buffer[18:20])
	f.Cafe = binary.BigEndian.Uint16(buffer[20:22])
	f.Deca = binary.BigEndian.Uint16(buffer[22:24])
	f.Counters[0] = binary.BigEndian.Uint16(buffer[24:26])
	f.Counters[1] = binary.BigEndian.Uint16(buffer[26:28])
	f.Counters[2] = binary.BigEndian.Uint16(buffer[28:30])
	f.Counters[3] = binary.BigEndian.Uint16(buffer[30:32])
	f.TimeStamps[0] = binary.BigEndian.Uint16(buffer[32:34])
	f.TimeStamps[1] = binary.BigEndian.Uint16(buffer[34:36])
	f.TimeStamps[2] = binary.BigEndian.Uint16(buffer[36:38])
	f.TimeStamps[3] = binary.BigEndian.Uint16(buffer[38:40])
	f.NoSamples = binary.BigEndian.Uint16(buffer[40:42])

	f.AMCFrameCounter = (uint32(f.AMCFrameCounters[0]) << 16) + uint32(f.AMCFrameCounters[1])
	// 	f.FrontEndId = (f.ParityFEIdCtrl & 0x7fff) >> 8
	// 	f.ASMFrameCounter = (uint64(f.ASMFrameCounters[0]) << 48) + (uint64(f.ASMFrameCounters[1]) << 32) + (uint64(f.ASMFrameCounters[2]) << 16) + uint64(f.ASMFrameCounters[3])
	// 	temp := (uint64(f.TimeStamps[0]) << 16) | uint64(f.TimeStamps[1])
	// 	temp = (temp << 32)
	// 	temp1 := (uint64(f.TimeStamps[2]) << 16) | uint64(f.TimeStamps[3])
	// 	// 	temp |= temp1
	// 	f.TimeStamp = temp | temp1
	///////////////////////////////////////////////////////////////////////
	// This +11 is necessary but currently not really understood
	// 11 clock periods are generated by "machine d'etat" in ASM firmware
	// These additionnal 11 samples should currently be considered junk
	f.Data.SetNoSamples(f.NoSamples + 11)
	///////////////////////////////////////////////////////////////////////
}

func (f *Frame) IntegrityHeader() error {
	if f.FirstBlockWord != ctrlFirstWord {
		return fmt.Errorf("asm: missing %x magic\n", ctrlFirstWord)
	}
	if (f.ParityFEIdCtrl & 0xff) != ctrl0xfe {
		return fmt.Errorf("asm: missing %x magic\n", ctrl0xfe)
	}
	if f.Cafe != ctrl0xCafe {
		return fmt.Errorf("asm: missing %x magic\n", ctrl0xCafe)
	}
	if f.Deca != ctrl0xDeca {
		return fmt.Errorf("asm: missing %x magic\n", ctrl0xDeca)
	}
	return nil
}

// readParityChanIdCtrl is a temporary fix, until we understand where the additionnal 16 bits words come from
func (f *Frame) fillParityChanIdCtrl(buffer []byte, i int) (bool, int) {
	data := &f.Data.Data[i]
	beg := 42 + i*2*1023 + 2*f.noAttempts
	end := 44 + i*2*1023 + 2*f.noAttempts
	data.ParityChanIdCtrl = binary.BigEndian.Uint16(buffer[beg:end])

	//fmt.Printf("%v, %x (f.noAttempts=%v)\n", i, data.ParityChanIdCtrl, f.noAttempts)
	if (data.ParityChanIdCtrl & 0xff) != ctrl0xfd {
		//panic("(data.ParityChanIdCtrl & 0xff) != ctrl0xfd")
		return true, 0
	}
	data.Channel = (data.ParityChanIdCtrl & 0x7f00) >> 8
	if data.Channel != f.Data.Data[0].Channel+uint16(i) {
		//panic("reader.readParityChanIdCtrl: data.Channel != f.Data.Data[0].Channel+uint16(i)")
		return true, 0
	}
	f.QuartetAbsIdx60 = dpgadetector.FEIdAndChanIdToQuartetAbsIdx60(f.FrontEndId, data.Channel)
	//fmt.Printf("   -> %v, %v, %v\n", data.Channel, f.QuartetAbsIdx60, f.QuartetAbsIdx60old)
	if i > 0 && f.QuartetAbsIdx60 != f.QuartetAbsIdx60old {
		//panic("i > 0 && f.QuartetAbsIdx60 != f.QuartetAbsIdx60old")
		return true, 0
	}
	f.QuartetAbsIdx60old = f.QuartetAbsIdx60
	return false, end
}

func (f *Frame) FillData(buffer []byte) {
	for i := range f.Data.Data {
		data := &f.Data.Data[i]
		var pb bool
		var lastIdx int
		for pb, lastIdx = f.fillParityChanIdCtrl(buffer, i); pb == true; {
			f.noAttempts++
			if f.noAttempts >= 4 {
				log.Fatalf("reader.readParityChanIdCtrl: f.noAttempts >= 4\n")
			}
		}
		if f.noAttempts == 1 {
			f.Err = ErrorCode1
		}
		f.noAttempts = 0
		fmt.Println("lastIdx=", lastIdx)
		//fmt.Printf("data.ParityChanIdCtrl = %x\n", data.ParityChanIdCtrl)
		for j := range data.Amplitudes {
			//data.Amplitudes[j] = binary.BigEndian.Uint16(buffer[44+2*j+i*2*1023+2*f.noAttempts : 46+2*j+i*2*1023+2*f.noAttempts])
			data.Amplitudes[j] = binary.BigEndian.Uint16(buffer[lastIdx+2*j : lastIdx+2+2*j])
		}
		// 		for j := range data.Amplitudes {
		// 			fmt.Printf("data.Amplitudes[%v] = %x\n", j, data.Amplitudes[j])
		// 		}
	}
}

func (f *Frame) IntegrityData() error {
	for i := range f.Data.Data {
		if (f.Data.Data[i].ParityChanIdCtrl & 0xff) != ctrl0xfd {
			return fmt.Errorf("asm: missing %x magic\n", ctrl0xfd)
		}
	}
	return nil
}

func (f *Frame) fillTrailer(buffer []byte) {
	if f.Err == ErrorCode1 {
		f.CRC = binary.BigEndian.Uint16(buffer[len(buffer)-4 : len(buffer)-2])
		f.ParityFEIdCtrl2 = binary.BigEndian.Uint16(buffer[len(buffer)-2 : len(buffer)])
	} else {
		f.CRC = binary.BigEndian.Uint16(buffer[len(buffer)-12 : len(buffer)-10])
		f.ParityFEIdCtrl2 = binary.BigEndian.Uint16(buffer[len(buffer)-10 : len(buffer)-8])
	}
}

func (f *Frame) IntegrityTrailer() error {
	if f.CRC != ctrl0xCRC {
		return fmt.Errorf("asm: missing %x magic\n", ctrl0xCRC)
	}
	if (f.ParityFEIdCtrl2 & 0xff) != ctrl0xfb {
		return fmt.Errorf("asm: missing %x magic\n", ctrl0xfb)
	}
	if (f.ParityFEIdCtrl2&0x7fff)>>8 != f.FrontEndId {
		log.Fatalf("Front end ids in header and trailer don't match\n")
	}
	return nil
}

func (f *Frame) Print(s string) {
	fmt.Printf(" Printing block (UDP payload size=%v):\n", f.UDPPayloadSize)
	fmt.Printf("   -> FirstBlockWord = %x\n", f.FirstBlockWord)
	fmt.Printf("   -> AMCFrameCounters = %x (AMCFrameCounter = %v)\n", f.AMCFrameCounters, f.AMCFrameCounter)
	fmt.Printf("   -> ParityFEIdCtrl = %x (FrontEndId = %x)\n", f.ParityFEIdCtrl, f.FrontEndId)
	fmt.Printf("   -> TriggerMode = %x\n", f.TriggerMode)
	fmt.Printf("   -> Trigger = %x\n", f.Trigger)
	fmt.Printf("   -> ASMFrameCounters = %x (ASMFrameCounter = %v)\n", f.ASMFrameCounters, f.ASMFrameCounter)
	fmt.Printf("   -> Cafe = %x\n", f.Cafe)
	fmt.Printf("   -> Deca = %x\n", f.Deca)
	fmt.Printf("   -> Counters = %x\n", f.Counters)
	fmt.Printf("   -> TimeStamps = %x (TimeStamp = %v)\n", f.TimeStamps, f.TimeStamp)
	fmt.Printf("   -> NoSamples = %x\n", f.NoSamples)

	switch s {
	case "short":
	case "medium":
		for i := range f.Data.Data {
			data := &f.Data.Data[i]
			fmt.Printf("   -> ParityChanIdCtrl = %x (channel = %v)\n", data.ParityChanIdCtrl, data.Channel)
			fmt.Printf("   -> Amplitudes[0] = %x\n", data.Amplitudes[0])
			fmt.Printf("   -> Amplitudes[1] = %x\n", data.Amplitudes[1])
			fmt.Printf("   -> Amplitudes[2] = %x\n", data.Amplitudes[2])
			fmt.Printf("   -> Amplitudes[3] = %x\n", data.Amplitudes[3])
			fmt.Printf("   ->    ...\n")
			fmt.Printf("   -> Amplitudes[1008] = %x\n", data.Amplitudes[1008])
			fmt.Printf("   -> Amplitudes[1009] = %x\n", data.Amplitudes[1009])
			fmt.Printf("   -> Amplitudes[1010] = %x\n", data.Amplitudes[1010])
		}
		/*
			case "long":
				fmt.Printf("  Data %v = %x\n", 0, f.Data[0])
				fmt.Printf("  Data %v = %x\n", 1, f.Data[1])
				fmt.Printf("  Data %v = %x\n", 2, f.Data[2])
				fmt.Printf("  Data %v = %x\n", 3, f.Data[3])
				fmt.Println("\t.\n\t.")
				fmt.Printf("  Data %v = %x\n", len(f.Data)-3, f.Data[len(f.Data)-3])
				fmt.Printf("  Data %v = %x\n", len(f.Data)-2, f.Data[len(f.Data)-2])
				fmt.Printf("  Data %v = %x\n", len(f.Data)-1, f.Data[len(f.Data)-1])
				fmt.Printf("  SRout = %v\n", f.SRout)
				for i := range f.Counters {
					fmt.Printf("  Counter %v = %v\n", i, f.Counters[i])
				}
		*/
	case "full":
		for i := range f.Data.Data {
			data := &f.Data.Data[i]
			fmt.Printf("   -> ParityChanIdCtrl = %x\n", data.ParityChanIdCtrl)
			fmt.Printf("   -> Amplitudes = %x\n", data.Amplitudes)
		}
	}

}

func (f *Frame) Buffer() []byte {
	var buffer []uint16
	buffer = append(buffer, f.FirstBlockWord)
	buffer = append(buffer, f.AMCFrameCounters[:]...)
	buffer = append(buffer, f.ParityFEIdCtrl)
	buffer = append(buffer, f.TriggerMode)
	buffer = append(buffer, f.Trigger)
	buffer = append(buffer, f.ASMFrameCounters[:]...)
	buffer = append(buffer, f.Cafe)
	buffer = append(buffer, f.Deca)
	buffer = append(buffer, f.Counters[:]...)
	buffer = append(buffer, f.TimeStamps[:]...)
	buffer = append(buffer, f.NoSamples)
	for i := range f.Data.Data {
		data := &f.Data.Data[i]
		buffer = append(buffer, data.ParityChanIdCtrl)
		buffer = append(buffer, data.Amplitudes...)
		if f.Err == ErrorCode1 {
			//fmt.Println("ErrorCode1, add extra word")
			buffer = append(buffer, uint16(0))
		}
	}
	buffer = append(buffer, f.CRC)
	buffer = append(buffer, f.ParityFEIdCtrl2)

	var buffer8 []byte
	for i := range buffer {
		buffer8 = append(buffer8, uint8(buffer[i]>>8))
		buffer8 = append(buffer8, uint8(buffer[i]&0xFFFF))
		//fmt.Printf("buffer8 = %x %x\n", buffer8[len(buffer8)-2], buffer8[len(buffer8)-1])
	}
	return buffer8
}
